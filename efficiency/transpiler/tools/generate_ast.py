import sys
from typing import List


class GenerateAst:
    @staticmethod
    def main(args):
        if len(args) != 1:
            print("Usage: generate_ast <output directory>")
            sys.exit(64)

        output_dir = args[0]
        GenerateAst.define_ast(
            output_dir,
            "Expr",
            [
                "Binary : Token operator, Expr left, Expr right",
                "Unary  : Token operator, Expr right",
                "If     : Expr condition, Expr then_branch, Expr else_branch",
                "Literal: Token operator, object value",
                "Lambda: Token operator, Expr function",
                "Lambda_Var: Token operator",
            ],
        )

        # GenerateAst.define_ast(
        #     output_dir,
        #     "Stmt",
        #     [
        #         "Expression :Expr expression",
        #         "Function   :Token name, List[Token] params, List[Stmt] body",
        #         "If         :Expr condition, Stmt then_branch, Stmt else_branch",
        #         "Print      :Expr expression",
        #         "Return     :Token keyword, Expr value",
        #         "While      :Expr condition, Stmt body",
        #         "Var        :Token name, Expr initializer",
        #         "Block      :List[Stmt] statements",
        #     ],
        # )

    @staticmethod
    def define_ast(output_dir: str, base_name: str, types: List[str]):
        path = f"{output_dir}/{base_name}.py"
        with open(path, "w") as f:
            f.write("# Path: plox/Expr.py\n")
            f.write(
                "# This file was automatically generated by plox/tools/generate_ast.py\n"
            )
            f.write("from typing import Any, List\n")
            f.write("from Token import Token\n")
            f.write("from abc import ABC, ABCMeta, abstractmethod\n")
            if base_name != "Expr":
                f.write("from .Expr import Expr\n")
            f.write("\n")
            f.write("\n")
            f.write(f"class {base_name}(ABC):\n")
            f.write("    @abstractmethod\n")
            f.write(f'    def accept(visitor: "{base_name}Visitor")-> Any:\n')
            f.write("        pass\n")
            f.write("\n")

            GenerateAst.define_visitor(f, base_name, types)

            for type in types:
                class_name = type.split(":")[0].strip()
                fields = type.split(":")[1].strip()
                GenerateAst.define_type(f, base_name, class_name, fields)
                f.write("\n")

    @staticmethod
    def define_type(f, base_name: str, class_name: str, fields: str) -> None:
        tmp = fields.split(", ")
        python_fields = ",".join(
            [f"{field.split(' ')[1]}:{field.split(' ')[0]}" for field in tmp]
        )
        f.write(f"class {class_name}({base_name}):\n")
        f.write(f"    def __init__(self, {python_fields}):\n")
        for field in tmp:
            name = field.split(" ")[1]
            f.write(f"        self.{name} = {name}\n")
        f.write("\n")

        f.write(f"    def accept(self, visitor: '{base_name}Visitor') -> Any:\n")
        f.write(
            f"        return visitor.visit_{class_name.lower()}_{base_name.lower()}(self)\n"
        )

    @staticmethod
    def define_visitor(f, base_name: str, types: List[str]):
        f.write("\n")
        f.write("\n")
        f.write(f"class {base_name}Visitor(ABC):\n")
        f.write("    pass\n")
        f.write("\n")
        for type in types:
            type_name = type.split(":")[0].strip()
            f.write(f"    @abstractmethod\n")
            f.write(
                f'    def visit_{type_name.lower()}_{base_name.lower()}(self, {base_name.lower()}:"{type_name}"):\n'
            )
            f.write(f"        pass\n")
            f.write("\n")


if __name__ == "__main__":
    GenerateAst.main(["../generated"])
